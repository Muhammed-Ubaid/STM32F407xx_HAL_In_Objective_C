/*
 * STM32F407xx_GPIO_Driver.c
 *
 *  Created on: Oct 19, 2023
 *      Author: Ubaid
 */
#include <stdio.h>
#include <STM32F407xx_GPIO_Driver_Definitions_Public.h>
#include <STM32F407xx_GPIO_Driver_Definitions_Private.h>

void GPIO_PeriClockControl(GPIO_RegDef_t *pGPIOx, uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
	{
		if(pGPIOx == GPIOA)
		{
			GPIOA_PCLK_EN();
		}
		else if(pGPIOx == GPIOB)
		{
			GPIOB_PCLK_EN();
		}
		else if(pGPIOx == GPIOC)
		{
			GPIOC_PCLK_EN();
		}
		else if(pGPIOx == GPIOD)
		{
			GPIOD_PCLK_EN();
		}
		else if(pGPIOx == GPIOE)
		{
			GPIOE_PCLK_EN();
		}
		else if(pGPIOx == GPIOF)
		{
			GPIOF_PCLK_EN();
		}
		else if(pGPIOx == GPIOG)
		{
			GPIOG_PCLK_EN();
		}
		else if(pGPIOx == GPIOH)
		{
			GPIOH_PCLK_EN();
		}
		else if(pGPIOx == GPIOI)
		{
			GPIOI_PCLK_EN();
		}
		else
		{
			/* Handle default error*/
		}
	}
	else
	{
		if(pGPIOx == GPIOA)
		{
			GPIOA_PCLK_DI();
		}
		else if(pGPIOx == GPIOB)
		{
			GPIOB_PCLK_DI();
		}
		else if(pGPIOx == GPIOC)
		{
			GPIOC_PCLK_DI();
		}
		else if(pGPIOx == GPIOD)
		{
			GPIOD_PCLK_DI();
		}
		else if(pGPIOx == GPIOE)
		{
			GPIOE_PCLK_DI();
		}
		else if(pGPIOx == GPIOF)
		{
			GPIOF_PCLK_DI();
		}
		else if(pGPIOx == GPIOG)
		{
			GPIOG_PCLK_DI();
		}
		else if(pGPIOx == GPIOH)
		{
			GPIOH_PCLK_DI();
		}
		else if(pGPIOx == GPIOI)
		{
			GPIOI_PCLK_DI();
		}
		else
		{
			/* Handle default error*/
		}

	}
}

void GPIO_Init(GPIO_Config_UserHandle_t UserHandle)
{
	GPIO_Handle_t initializer = {0};
	uint32_t temp_var = 0;
	//Create & Initialize private data
	UserHandle.Private_GPIO_Data = (GPIO_Handle_t*) malloc(sizeof(GPIO_Handle_t));

	memcpy(UserHandle.Private_GPIO_Data, initializer, (sizeof(GPIO_Handle_t));

	if(UserHandle.GPIO_PORT == PORT_GPIOA)
	{
		UserHandle->Private_GPIO_Data.pGPIOx = GPIOA;
	}
	else if(UserHandle.GPIO_PORT == PORT_GPIOB)
	{
		UserHandle->Private_GPIO_Data.pGPIOx = GPIOB;
	}
	else if(UserHandle.GPIO_PORT == PORT_GPIOC)
	{
		UserHandle->Private_GPIO_Data->pGPIOx = GPIOC;
	}

	// 1.Configure MODE of GPIO
	if(UserHandle.GPIO_PIN_MODE <= GPIO_MODE_ANALOG)
		{
		temp_var = (UserHandle.GPIO_PIN_MODE) <<(2*(UserHandle.GPIO_PIN_NUM));
		UserHandle->Private_GPIO_Data.pGPIOx.MODER = temp_var;
		temp_var = 0;
		}
	else
		{
//		interrupt
		}
	//2. Configure GPIO Speed
	temp_var = (UserHandle.GPIO_SPEED_TYPE) <<(2*(UserHandle.GPIO_PIN_NUM));
	UserHandle->Private_GPIO_Data.pGPIOx.OSPEEDR = temp_var;

	//3. Pull Up Pull down configuration



}





